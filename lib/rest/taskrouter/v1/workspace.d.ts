/**
 * This code was generated by
 * \ / _    _  _|   _  _
 *  | (_)\/(_)(_|\/| |(/_  v1.0.0
 *       /       /
 */

import Page = require('../../../base/Page');
import Response = require('../../../http/response');
import V1 = require('../V1');
import { ActivityListInstance } from './workspace/activity';
import { EventListInstance } from './workspace/event';
import { ListEachOptions, ListOptions, PageOptions } from '../../../interfaces';
import { SerializableClass } from '../../../interfaces';
import { TaskChannelListInstance } from './workspace/taskChannel';
import { TaskListInstance } from './workspace/task';
import { TaskQueueListInstance } from './workspace/taskQueue';
import { WorkerListInstance } from './workspace/worker';
import { WorkflowListInstance } from './workspace/workflow';
import { WorkspaceCumulativeStatisticsListInstance } from './workspace/workspaceCumulativeStatistics';
import { WorkspaceRealTimeStatisticsListInstance } from './workspace/workspaceRealTimeStatistics';
import { WorkspaceStatisticsListInstance } from './workspace/workspaceStatistics';

declare function WorkspaceList(version: V1): WorkspaceListInstance

type WorkspaceQueueOrder = 'FIFO'|'LIFO';

interface WorkspaceResource {
  /**
   * The ID of the account that owns this Workflow
   */
  account_sid: string;
  /**
   * The time the Workspace was created, given as GMT in ISO 8601 format.
   */
  date_created: Date;
  /**
   * The time the Workspace was last updated, given as GMT in ISO 8601 format.
   */
  date_updated: Date;
  /**
   * The human readable name of the default activity. Read only.
   */
  default_activity_name: string;
  /**
   * The ID of the Activity that will be used when new Workers are created in this Workspace.
   */
  default_activity_sid: string;
  /**
   * If provided, the Workspace will publish events to this URL. You can use this to gather data for reporting. See Workspace Events for more information.
   */
  event_callback_url: string;
  /**
   * Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. For example if 'EventsFilter=task.created,task.canceled,worker.activity.update', then TaskRouter will webhook to EventCallbackUrl only when a task is created, canceled or a worker activity is updated.
   */
  events_filter: string;
  /**
   * Filter by a workspace's friendly name. This is a human readable description of this Workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendly_name: string;
  /**
   * The links
   */
  links: string;
  /**
   * Multi tasking allows workers to handle multiple tasks simultaneously. When enabled (MultiTaskEnabled=true), each worker will be eligible to receive parallel reservations up to the per-channel maximums defined in the Workers section. Default is disabled (MultiTaskEnabled=false), where each worker will only receive a new reservation when the previous task is completed. Learn more by visiting [Multitasking][/docs/taskrouter/multitasking].
   */
  multi_task_enabled: boolean;
  /**
   * Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. Default is FIFO. [Click here][/docs/taskrouter/queue-ordering-last-first-out-lifo] to learn more about LIFO and the use of the parameter.
   */
  prioritize_queue_order: WorkspaceQueueOrder;
  /**
   * The unique ID of the Workspace
   */
  sid: string;
  /**
   * The human readable name of the timeout activity. Read only.
   */
  timeout_activity_name: string;
  /**
   * The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
   */
  timeout_activity_sid: string;
  /**
   * The url
   */
  url: string;
}

interface WorkspacePayload extends WorkspaceResource, Page.TwilioResponsePayload {
}

interface WorkspaceSolution {
}

interface WorkspaceListEachOptions extends ListEachOptions<WorkspaceInstance> {
  /**
   * Filter by a workspace's friendly name. This is a human readable description of this Workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendlyName?: string;
}

interface WorkspaceListOptions extends ListOptions<WorkspaceInstance> {
  /**
   * Filter by a workspace's friendly name. This is a human readable description of this Workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendlyName?: string;
}

interface WorkspaceListPageOptions extends PageOptions<WorkspacePage> {
  /**
   * Filter by a workspace's friendly name. This is a human readable description of this Workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendlyName?: string;
}

interface WorkspaceListCreateOptions {
  /**
   * If provided, the Workspace will publish events to this URL. You can use this to gather data for reporting. See Workspace Events for more information.
   */
  eventCallbackUrl?: string;
  /**
   * Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. For example if 'EventsFilter=task.created,task.canceled,worker.activity.update', then TaskRouter will webhook to EventCallbackUrl only when a task is created, canceled or a worker activity is updated.
   */
  eventsFilter?: string;
  /**
   * Human readable description of this workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendlyName: string;
  /**
   * Multi tasking allows workers to handle multiple tasks simultaneously. When enabled (MultiTaskEnabled=true), each worker will be eligible to receive parallel reservations up to the per-channel maximums defined in the Workers section. Default is disabled (MultiTaskEnabled=false), where each worker will only receive a new reservation when the previous task is completed. Learn more by visiting [Multitasking][/docs/taskrouter/multitasking].
   */
  multiTaskEnabled?: boolean;
  /**
   * Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. Default is FIFO. [Click here][/docs/taskrouter/queue-ordering-last-first-out-lifo] to learn more about LIFO and the use of the parameter.
   */
  prioritizeQueueOrder?: WorkspaceQueueOrder;
  /**
   * One of the available template names. Will pre-configure this Workspace with the Workflow and Activities specified in the template. "NONE" will create a Workspace with a set of default activities and nothing else. "FIFO" will configure TaskRouter with a set of default activities and a single task queue for first-in, first-out distribution, useful if you want to see a simple TaskRouter configuration when getting started. Defaults to "NONE".
   */
  template?: string;
}

interface WorkspaceListInstance {
  /**
   * Gets context of a single Workspace resource
   *
   * @param sid - The sid
   */
  (sid: string): WorkspaceContext;
  /**
   * create a WorkspaceInstance
   *
   * @param opts - Options for request
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  create(opts: WorkspaceListCreateOptions): Promise<WorkspaceInstance>;
  /**
   * create a WorkspaceInstance
   *
   * @param opts - Options for request
   * @param callback - Callback to handle processed record
   */
  create(opts: WorkspaceListCreateOptions, callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * Streams WorkspaceInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param opts - Options for request
   */
  each(opts?: WorkspaceListEachOptions): void;
  /**
   * Streams WorkspaceInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param callback - Callback to handle processed record
   */
  each(callback: (item: WorkspaceInstance, done: (err?: Error) => void) => void): any;
  /**
   * Gets context of a single Workspace resource
   *
   * @param sid - The sid
   */
  get(sid: string): WorkspaceContext;
  /**
   * Retrieve a single target page of WorkspaceInstance records from the API.
   * Request is executed immediately
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param targetUrl - API-generated URL for the requested results page
   */
  getPage(targetUrl: string): Promise<WorkspacePage>;
  /**
   * Retrieve a single target page of WorkspaceInstance records from the API.
   * Request is executed immediately
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param targetUrl - API-generated URL for the requested results page
   * @param callback - Callback to handle processed record
   */
  getPage(targetUrl: string, callback: (error: Error | null, items: WorkspacePage) => any): void;
  /**
   * Lists WorkspaceInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param opts - Options for request
   */
  list(opts?: WorkspaceListOptions): Promise<WorkspaceInstance[]>;
  /**
   * Lists WorkspaceInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param opts - Options for request
   * @param callback - Callback to handle processed record
   */
  list(opts: WorkspaceListOptions, callback: (error: Error | null, items: WorkspaceInstance[]) => any): void;
  /**
   * Lists WorkspaceInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param callback - Callback to handle processed record
   */
  list(callback: (error: Error | null, items: WorkspaceInstance[]) => any): void;
  /**
   * Retrieve a single page of WorkspaceInstance records from the API.
   * Request is executed immediately
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param opts - Options for request
   */
  page(opts?: WorkspaceListPageOptions): Promise<WorkspacePage>;
  /**
   * Retrieve a single page of WorkspaceInstance records from the API.
   * Request is executed immediately
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param opts - Options for request
   * @param callback - Callback to handle processed record
   */
  page(opts: WorkspaceListPageOptions, callback: (error: Error | null, items: WorkspacePage) => any): void;
  /**
   * Retrieve a single page of WorkspaceInstance records from the API.
   * Request is executed immediately
   *
   * If a function is passed as the first argument, it will be used as the callback function.
   *
   * @param callback - Callback to handle processed record
   */
  page(callback: (error: Error | null, items: WorkspacePage) => any): void;
}

interface WorkspaceListFetchOptions {
  /**
   * The ID of the Activity that will be used when new Workers are created in this Workspace.
   */
  defaultActivitySid?: string;
  /**
   * The Workspace will publish events to this URL. You can use this to gather data for reporting. See [Events][/docs/taskrouter/api/events] for more information.
   */
  eventCallbackUrl?: string;
  /**
   * Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. For example if 'EventsFilter=task.created,task.canceled,worker.activity.update', then TaskRouter will webhook to EventCallbackUrl only when a task is created, canceled or a worker activity is updated.
   */
  eventsFilter?: string;
  /**
   * Human readable description of this workspace (for example "Sales Call Center" or "Customer Support Team")
   */
  friendlyName?: string;
  /**
   * Enable or Disable Multitasking by passing either *true* or *False* with the POST request. Learn more by visiting [Multitasking][/docs/taskrouter/multitasking].
   */
  multiTaskEnabled?: boolean;
  /**
   * Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. Default is FIFO. [Click here][/docs/taskrouter/queue-ordering-last-first-out-lifo] to learn more about LIFO and the use of the parameter.
   */
  prioritizeQueueOrder?: WorkspaceQueueOrder;
  /**
   * The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
   */
  timeoutActivitySid?: string;
}

interface WorkspaceListFetchOptions {
  /**
   * The ID of the Activity that will be used when new Workers are created in this Workspace.
   */
  defaultActivitySid?: string;
  /**
   * The Workspace will publish events to this URL. You can use this to gather data for reporting. See [Events][/docs/taskrouter/api/events] for more information.
   */
  eventCallbackUrl?: string;
  /**
   * Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. For example if 'EventsFilter=task.created,task.canceled,worker.activity.update', then TaskRouter will webhook to EventCallbackUrl only when a task is created, canceled or a worker activity is updated.
   */
  eventsFilter?: string;
  /**
   * Human readable description of this workspace (for example "Sales Call Center" or "Customer Support Team")
   */
  friendlyName?: string;
  /**
   * Enable or Disable Multitasking by passing either *true* or *False* with the POST request. Learn more by visiting [Multitasking][/docs/taskrouter/multitasking].
   */
  multiTaskEnabled?: boolean;
  /**
   * Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. Default is FIFO. [Click here][/docs/taskrouter/queue-ordering-last-first-out-lifo] to learn more about LIFO and the use of the parameter.
   */
  prioritizeQueueOrder?: WorkspaceQueueOrder;
  /**
   * The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
   */
  timeoutActivitySid?: string;
}

declare class WorkspacePage extends Page<V1, WorkspacePayload, WorkspaceResource, WorkspaceInstance> {
  constructor(version: V1, response: Response<string>, solution: WorkspaceSolution);

  /**
   * Build an instance of WorkspaceInstance
   *
   * @param payload - Payload response from the API
   */
  getInstance(payload: WorkspacePayload): WorkspaceInstance;
}

declare class WorkspaceInstance extends SerializableClass {
  /**
   * @param version - Version of the resource
   * @param payload - The instance payload
   * @param sid - The sid
   */
  constructor(version: V1, payload: WorkspacePayload, sid: string);

  private _proxy: WorkspaceContext;
  /**
   * The ID of the account that owns this Workflow
   */
  accountSid: string;
  activities(): ActivityListInstance;
  cumulativeStatistics(): WorkspaceCumulativeStatisticsListInstance;
  /**
   * The time the Workspace was created, given as GMT in ISO 8601 format.
   */
  dateCreated: Date;
  /**
   * The time the Workspace was last updated, given as GMT in ISO 8601 format.
   */
  dateUpdated: Date;
  /**
   * The human readable name of the default activity. Read only.
   */
  defaultActivityName: string;
  /**
   * The ID of the Activity that will be used when new Workers are created in this Workspace.
   */
  defaultActivitySid: string;
  /**
   * If provided, the Workspace will publish events to this URL. You can use this to gather data for reporting. See Workspace Events for more information.
   */
  eventCallbackUrl: string;
  events(): EventListInstance;
  /**
   * Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. For example if 'EventsFilter=task.created,task.canceled,worker.activity.update', then TaskRouter will webhook to EventCallbackUrl only when a task is created, canceled or a worker activity is updated.
   */
  eventsFilter: string;
  /**
   * fetch a WorkspaceInstance
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  fetch(): Promise<WorkspaceInstance>;
  /**
   * fetch a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  fetch(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * Filter by a workspace's friendly name. This is a human readable description of this Workspace (for example "Customer Support" or "2014 Election Campaign")
   */
  friendlyName: string;
  /**
   * The links
   */
  links: string;
  /**
   * Multi tasking allows workers to handle multiple tasks simultaneously. When enabled (MultiTaskEnabled=true), each worker will be eligible to receive parallel reservations up to the per-channel maximums defined in the Workers section. Default is disabled (MultiTaskEnabled=false), where each worker will only receive a new reservation when the previous task is completed. Learn more by visiting [Multitasking][/docs/taskrouter/multitasking].
   */
  multiTaskEnabled: boolean;
  /**
   * Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. Default is FIFO. [Click here][/docs/taskrouter/queue-ordering-last-first-out-lifo] to learn more about LIFO and the use of the parameter.
   */
  prioritizeQueueOrder: WorkspaceQueueOrder;
  realTimeStatistics(): WorkspaceRealTimeStatisticsListInstance;
  /**
   * remove a WorkspaceInstance
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  remove(): Promise<WorkspaceInstance>;
  /**
   * remove a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  remove(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * The unique ID of the Workspace
   */
  sid: string;
  statistics(): WorkspaceStatisticsListInstance;
  taskChannels(): TaskChannelListInstance;
  taskQueues(): TaskQueueListInstance;
  tasks(): TaskListInstance;
  /**
   * The human readable name of the timeout activity. Read only.
   */
  timeoutActivityName: string;
  /**
   * The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
   */
  timeoutActivitySid: string;
  /**
   * update a WorkspaceInstance
   *
   * @param opts - Options for request
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  update(opts?: WorkspaceListFetchOptions): Promise<WorkspaceInstance>;
  /**
   * update a WorkspaceInstance
   *
   * @param opts - Options for request
   * @param callback - Callback to handle processed record
   */
  update(opts: WorkspaceListFetchOptions, callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * update a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  update(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * The url
   */
  url: string;
  workers(): WorkerListInstance;
  workflows(): WorkflowListInstance;
}

declare class WorkspaceContext {
  constructor(version: V1, sid: string);

  activities: ActivityListInstance;
  cumulativeStatistics: WorkspaceCumulativeStatisticsListInstance;
  events: EventListInstance;
  /**
   * fetch a WorkspaceInstance
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  fetch(): Promise<WorkspaceInstance>;
  /**
   * fetch a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  fetch(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  realTimeStatistics: WorkspaceRealTimeStatisticsListInstance;
  /**
   * remove a WorkspaceInstance
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  remove(): Promise<WorkspaceInstance>;
  /**
   * remove a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  remove(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  statistics: WorkspaceStatisticsListInstance;
  taskChannels: TaskChannelListInstance;
  taskQueues: TaskQueueListInstance;
  tasks: TaskListInstance;
  /**
   * update a WorkspaceInstance
   *
   * @param opts - Options for request
   *
   * @returns Promise that resolves to processed WorkspaceInstance
   */
  update(opts?: WorkspaceListFetchOptions): Promise<WorkspaceInstance>;
  /**
   * update a WorkspaceInstance
   *
   * @param opts - Options for request
   * @param callback - Callback to handle processed record
   */
  update(opts: WorkspaceListFetchOptions, callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  /**
   * update a WorkspaceInstance
   *
   * @param callback - Callback to handle processed record
   */
  update(callback: (error: Error | null, items: WorkspaceInstance) => any): void;
  workers: WorkerListInstance;
  workflows: WorkflowListInstance;
}

export { WorkspaceContext, WorkspaceInstance, WorkspaceList, WorkspaceListCreateOptions, WorkspaceListEachOptions, WorkspaceListFetchOptions, WorkspaceListInstance, WorkspaceListOptions, WorkspaceListPageOptions, WorkspacePage, WorkspacePayload, WorkspaceQueueOrder, WorkspaceResource, WorkspaceSolution }
